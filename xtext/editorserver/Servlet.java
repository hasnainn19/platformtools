/*
 * generated by Xtext 2.29.0
 */
package DSLQNAME;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.epsilon.egl.EglTemplateFactoryModuleAdapter;
import org.eclipse.epsilon.emc.emf.InMemoryEmfModel;
import org.eclipse.xtext.resource.IResourceServiceProvider;
import org.eclipse.xtext.resource.XtextResourceSet;
import org.eclipse.xtext.util.DisposableRegistry;
import org.eclipse.xtext.web.server.IServiceContext;
import org.eclipse.xtext.web.server.ISession;
import org.eclipse.xtext.web.server.InvalidRequestException;
import org.eclipse.xtext.web.server.XtextServiceDispatcher;
import org.eclipse.xtext.web.server.generator.GeneratorService;
import org.eclipse.xtext.web.servlet.HttpSessionWrapper;
import org.eclipse.xtext.web.servlet.XtextServlet;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.inject.Injector;

import net.sourceforge.plantuml.FileFormat;
import net.sourceforge.plantuml.FileFormatOption;
import net.sourceforge.plantuml.SourceStringReader;

/**
 * Deploy this class into a servlet container to enable DSL-specific services.
 *
 * This particular implementation provides additional services as part of the Xtext tool.
 */
@WebServlet(name = "XtextServices", urlPatterns = "/xtext-service/*")
public class DSLNAMEServlet extends XtextServlet {

    private static final long serialVersionUID = 1L;

    DisposableRegistry disposableRegistry;

    public void init() throws ServletException {
        super.init();
        Injector injector = new DSLNAMEWebSetup().createInjectorAndDoEMFRegistration();
        this.disposableRegistry = injector.getInstance(DisposableRegistry.class);
    }

	private interface IResponse {
	}

	private class ToXMIResponse implements IResponse {
		public String output;
	}

	private class ErrorResponse implements IResponse {
		public String error;
	}

	private class ToDiagramResponse implements IResponse {
		public String diagram;
	}
	
	private class GenerationResponse implements IResponse{
		public List<GeneratedFile> generatedFiles;
	}
	
	private class GeneratedFile {
		public String name;
		public String contents;
		
		public GeneratedFile(String name, String contents) {
			this.name = name;
			this.contents = contents;
		}
	}

	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		String serviceID = req.getPathInfo().substring(1);
		IResponse response = null;

		switch (serviceID) {
		case "to-xmi":
			String sResult = exportXMI(req);

			if (sResult != "") {
				response = new ToXMIResponse();
				((ToXMIResponse) response).output = sResult;
			} else {
				response = new ErrorResponse();
				((ErrorResponse) response).error = "Unable to generate XMI.";
			}

			break;
		case "to-diagram":
			sResult = exportDiagram(req);

			if (sResult != "") {
				response = new ToDiagramResponse();
				((ToDiagramResponse) response).diagram = sResult;
			} else {
				response = new ErrorResponse();
				((ErrorResponse) response).error = "Unable to generate diagram.";
			}

			break;
		case "runGenerator":
			var result = doGenerate(req);
			
			if (result != null) {
				response = new GenerationResponse();
				for (var file: result.getArtifacts()) {
					((GenerationResponse)response).generatedFiles.add(new GeneratedFile(file.getName(), file.getContent()));
				}
			} else {
				response = new ErrorResponse();
				((ErrorResponse) response).error = "Unable to run code generator.";
			}
			
			break;
		default:
			super.doPost(req, resp);
			return;
		}

		resp.setStatus(HttpServletResponse.SC_OK);
		resp.setContentType("application/json");
		PrintWriter pw = resp.getWriter();

		pw.print(new Gson().toJson(response));

		pw.close();
	}

	private final class HttpServiceContext implements IServiceContext {

		private final HttpServletRequest request;
		private HttpSessionWrapper sessionWrapper;		
		private final Map<String, String> parameters = new HashMap<>();
		
		public HttpServiceContext (HttpServletRequest req) throws IOException {
			this.request = req;
			initialise();
		}
		
		private void initialise() throws IOException {
			for (String param: request.getParameterMap().keySet()) {
				parameters.put(param, request.getParameter(param));
			}
			
			JsonObject jsoParameters = JsonParser.parseReader(request.getReader()).getAsJsonObject();
			String serviceID = request.getPathInfo().substring(1);
			
			parameters.put(SERVICE_TYPE, serviceID);
			
			for (var jsoParam: jsoParameters.entrySet()) {
				parameters.put(jsoParam.getKey(), jsoParam.getValue().toString());
			}
		}
		
		@Override
		public Set<String> getParameterKeys() {
			return parameters.keySet();
		}

		@Override
		public String getParameter(String key) {
			return parameters.get(key);
		}

		@Override
		public ISession getSession() {
			if (sessionWrapper == null) {
				sessionWrapper = new HttpSessionWrapper(request.getSession(true));
			}
			return sessionWrapper;
		}
	}
	
	private class RequestStructure {
		public String input;
	}

    /**
     * Handles the 'to-xmi' command by transforming the model code in parameter 'input', given in the Xtext format of the DSML managed by this editor, into a regular XMI file.
     */
	private String exportXMI(HttpServletRequest req)
			throws InvalidRequestException.UnknownLanguageException, IOException {
		BufferedReader reader = req.getReader();
		RequestStructure reqObj = new Gson().fromJson(reader, RequestStructure.class);

		URI emfURI = URI.createURI("input.LANGUAGE_EXT");
		IResourceServiceProvider resourceServiceProvider = IResourceServiceProvider.Registry.INSTANCE
				.getResourceServiceProvider(emfURI);
		if (resourceServiceProvider == null) {
			throw new InvalidRequestException.UnknownLanguageException("Unable to identify the Xtext language.");
		}

		Injector injector = resourceServiceProvider.get(Injector.class);

		XtextResourceSet resourceSet = injector.getInstance(XtextResourceSet.class);

		Resource xtextResource = resourceSet.createResource(emfURI);
		xtextResource.load(new ByteArrayInputStream(reqObj.input.getBytes()), null);
		EcoreUtil.resolveAll(xtextResource);

		Resource xmiResource = resourceSet.createResource(URI.createFileURI("result.xmi"));
		xmiResource.getContents().add(xtextResource.getContents().get(0));
		try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
			xmiResource.save(baos, null);
			return baos.toString();
		} catch (IOException e) {
			e.printStackTrace();
		}

		return "";
	}

    /**
     * Handles the 'to-diagram' command by transforming the model code in parameter 'input', given in the Xtext format of the DSML managed by this editor, into an SVG object diagram generated by PlantUML.
     */
	private String exportDiagram(HttpServletRequest req)
			throws InvalidRequestException.UnknownLanguageException, IOException {
		BufferedReader reader = req.getReader();
		RequestStructure reqObj = new Gson().fromJson(reader, RequestStructure.class);

		URI emfURI = URI.createURI("input.LANGUAGE_EXT");
		IResourceServiceProvider resourceServiceProvider = IResourceServiceProvider.Registry.INSTANCE
				.getResourceServiceProvider(emfURI);
		if (resourceServiceProvider == null) {
			throw new InvalidRequestException.UnknownLanguageException("Unable to identify the Xtext language.");
		}

		Injector injector = resourceServiceProvider.get(Injector.class);

		XtextResourceSet resourceSet = injector.getInstance(XtextResourceSet.class);

		Resource xtextResource = resourceSet.createResource(emfURI);
		xtextResource.load(new ByteArrayInputStream(reqObj.input.getBytes()), null);
		EcoreUtil.resolveAll(xtextResource);

		try {
			EglTemplateFactoryModuleAdapter module = new EglTemplateFactoryModuleAdapter();

			String eglCode = new BufferedReader(
					new InputStreamReader(getClass().getResourceAsStream("model2plantuml.egl"))).lines()
					.collect(Collectors.joining("\n"));
			module.parse(eglCode);

			InMemoryEmfModel model = new InMemoryEmfModel(xtextResource);
			model.setName("M");

			module.getContext().getModelRepository().addModel(model);
			String plantUml = module.execute() + "";

			SourceStringReader ssr = new SourceStringReader(plantUml);
			ByteArrayOutputStream os = new ByteArrayOutputStream();
			ssr.outputImage(os, new FileFormatOption(FileFormat.SVG));
			os.close();

			return new String(os.toByteArray(), Charset.forName("UTF-8"));
		} catch (Exception e) {
			throw new IOException(e);
		}
	}

	/**
	 * Expect to receive the following parameters:
	 * 
	 * - "fullText": text of model (xtext file)
	 * - "allArtifacts": Boolean to indicate if we need all files, should normally be true
	 * - "resource": file name of the xtext file, so that code generator can access this in the file names it generates
	 */
	private GeneratorService.GeneratedArtifacts doGenerate(HttpServletRequest req) throws IOException {
		HttpServiceContext context = new HttpServiceContext(req);
		
		URI emfURI = URI.createURI("input.LANGUAGE_EXT");
		IResourceServiceProvider resourceServiceProvider = IResourceServiceProvider.Registry.INSTANCE
				.getResourceServiceProvider(emfURI);
		if (resourceServiceProvider == null) {
			throw new InvalidRequestException.UnknownLanguageException("Unable to identify the Xtext language.");
		}

		Injector injector = resourceServiceProvider.get(Injector.class);

		XtextServiceDispatcher serviceDispatcher = injector.getInstance(XtextServiceDispatcher.class);
		XtextServiceDispatcher.ServiceDescriptor service = serviceDispatcher.getService(context);

		return (GeneratorService.GeneratedArtifacts) service.getService().apply();		
	}

    public void destroy() {
        if (disposableRegistry != null) {
            disposableRegistry.dispose();
            disposableRegistry = null;
        }
        super.destroy();
    }
}
